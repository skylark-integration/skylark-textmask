{"version":3,"sources":["skylark-textmask.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-textmask.js","sourcesContent":["define('skylark-textmask/textmask',[\r\n\t\"skylark-langx/skylark\"\r\n],function (skylark) {\r\n    'use strict';\r\n\r\n\treturn skylark.attach(\"intg.textmask\",{\r\n\t});\t\t\r\n\r\n}); \ndefine('skylark-textmask/adjustCaretPosition',[\n    \"./textmask\"\n],function (textmask) {\n    'use strict';\n    const defaultArray = [];\n    const emptyString = '';\n\n    function adjustCaretPosition({previousConformedValue = emptyString, previousPlaceholder = emptyString, currentCaretPosition = 0, conformedValue, rawValue, placeholderChar, placeholder, indexesOfPipedChars = defaultArray, caretTrapIndexes = defaultArray}) {\n        if (currentCaretPosition === 0 || !rawValue.length) {\n            return 0;\n        }\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const conformedValueLength = conformedValue.length;\n        const editLength = rawValueLength - previousConformedValueLength;\n        const isAddition = editLength > 0;\n        const isFirstRawValue = previousConformedValueLength === 0;\n        const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n        if (isPartialMultiCharEdit) {\n            return currentCaretPosition;\n        }\n        const possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n        let startingSearchIndex = 0;\n        let trackRightCharacter;\n        let targetChar;\n        if (possiblyHasRejectedChar) {\n            startingSearchIndex = currentCaretPosition - editLength;\n        } else {\n            const normalizedConformedValue = conformedValue.toLowerCase();\n            const normalizedRawValue = rawValue.toLowerCase();\n            const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString);\n            const intersection = leftHalfChars.filter(char => normalizedConformedValue.indexOf(char) !== -1);\n            targetChar = intersection[intersection.length - 1];\n            const previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n            const targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n            if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n                trackRightCharacter = true;\n                targetChar = rawValue[currentCaretPosition];\n            }\n            const pipedChars = indexesOfPipedChars.map(index => normalizedConformedValue[index]);\n            const countTargetCharInPipedChars = pipedChars.filter(char => char === targetChar).length;\n            const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n            const countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter((char, index) => char === targetChar && rawValue[index] !== char).length;\n            const requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (trackRightCharacter ? 1 : 0);\n            let numberOfEncounteredMatches = 0;\n            for (let i = 0; i < conformedValueLength; i++) {\n                const conformedValueChar = normalizedConformedValue[i];\n                startingSearchIndex = i + 1;\n                if (conformedValueChar === targetChar) {\n                    numberOfEncounteredMatches++;\n                }\n                if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n                    break;\n                }\n            }\n        }\n        if (isAddition) {\n            let lastPlaceholderChar = startingSearchIndex;\n            for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    lastPlaceholderChar = i;\n                }\n                if (placeholder[i] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === placeholderLength) {\n                    return lastPlaceholderChar;\n                }\n            }\n        } else {\n            if (trackRightCharacter) {\n                for (let i = startingSearchIndex - 1; i >= 0; i--) {\n                    if (conformedValue[i] === targetChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            } else {\n                for (let i = startingSearchIndex; i >= 0; i--) {\n                    if (placeholder[i - 1] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n\n    return textmask.adjustCaretPosition = adjustCaretPosition;\n});\ndefine('skylark-textmask/constants',[],function () {\n    'use strict';\n    const placeholderChar = '_';\n    const strFunction = 'function';\n    return {\n        placeholderChar: placeholderChar,\n        strFunction: strFunction\n    };\n});\ndefine('skylark-textmask/utilities',['./constants'], function (constants) {\n    'use strict';\n    const emptyArray = [];\n    function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = constants.placeholderChar) {\n        if (!isArray(mask)) {\n            throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\n        }\n        if (mask.indexOf(placeholderChar) !== -1) {\n            throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + `The placeholder character that was received is: ${ JSON.stringify(placeholderChar) }\\n\\n` + `The mask that was received is: ${ JSON.stringify(mask) }`);\n        }\n        return mask.map(char => {\n            return char instanceof RegExp ? placeholderChar : char;\n        }).join('');\n    }\n    function isArray(value) {\n        return Array.isArray && Array.isArray(value) || value instanceof Array;\n    }\n    function isString(value) {\n        return typeof value === 'string' || value instanceof String;\n    }\n    function isNumber(value) {\n        return typeof value === 'number' && value.length === undefined && !isNaN(value);\n    }\n    function isNil(value) {\n        return typeof value === 'undefined' || value === null;\n    }\n    const strCaretTrap = '[]';\n    function processCaretTraps(mask) {\n        const indexes = [];\n        let indexOfCaretTrap;\n        while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\n            indexes.push(indexOfCaretTrap);\n            mask.splice(indexOfCaretTrap, 1);\n        }\n        return {\n            maskWithoutCaretTraps: mask,\n            indexes\n        };\n    }\n    return {\n        convertMaskToPlaceholder: convertMaskToPlaceholder,\n        isArray: isArray,\n        isString: isString,\n        isNumber: isNumber,\n        isNil: isNil,\n        processCaretTraps: processCaretTraps\n    };\n});\ndefine('skylark-textmask/conformToMask',[\n    \"./textmask\",\n    './utilities',\n    './constants'\n], function (textmask,utilities,constants) {\n\n    const emptyArray = [];\n    const emptyString = '';\n\n    function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\n        if (!utilities.isArray(mask)) {\n            if (typeof mask === constants.strFunction) {\n                mask = mask(rawValue, config);\n                mask = utilities.processCaretTraps(mask).maskWithoutCaretTraps;\n            } else {\n                throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n            }\n        }\n        const {guide = true, previousConformedValue = emptyString, placeholderChar = constants.placeholderChar, placeholder = utilities.convertMaskToPlaceholder(mask, placeholderChar), currentCaretPosition, keepCharPositions} = config;\n        const suppressGuide = guide === false && previousConformedValue !== undefined;\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const maskLength = mask.length;\n        const editDistance = rawValueLength - previousConformedValueLength;\n        const isAddition = editDistance > 0;\n        const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0);\n        const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n        if (keepCharPositions === true && !isAddition) {\n            let compensatingPlaceholderChars = emptyString;\n            for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    compensatingPlaceholderChars += placeholderChar;\n                }\n            }\n            rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n        }\n        const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n            char,\n            isNew: i >= indexOfFirstChange && i < indexOfLastChange\n        }));\n        for (let i = rawValueLength - 1; i >= 0; i--) {\n            const {char} = rawValueArr[i];\n            if (char !== placeholderChar) {\n                const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n                if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n                    rawValueArr.splice(i, 1);\n                }\n            }\n        }\n        let conformedValue = emptyString;\n        let someCharsRejected = false;\n        placeholderLoop:\n            for (let i = 0; i < placeholderLength; i++) {\n                const charInPlaceholder = placeholder[i];\n                if (charInPlaceholder === placeholderChar) {\n                    if (rawValueArr.length > 0) {\n                        while (rawValueArr.length > 0) {\n                            const {\n                                char: rawValueChar,\n                                isNew\n                            } = rawValueArr.shift();\n                            if (rawValueChar === placeholderChar && suppressGuide !== true) {\n                                conformedValue += placeholderChar;\n                                continue placeholderLoop;\n                            } else if (mask[i].test(rawValueChar)) {\n                                if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString || guide === false || !isAddition) {\n                                    conformedValue += rawValueChar;\n                                } else {\n                                    const rawValueArrLength = rawValueArr.length;\n                                    let indexOfNextAvailablePlaceholderChar = null;\n                                    for (let i = 0; i < rawValueArrLength; i++) {\n                                        const charData = rawValueArr[i];\n                                        if (charData.char !== placeholderChar && charData.isNew === false) {\n                                            break;\n                                        }\n                                        if (charData.char === placeholderChar) {\n                                            indexOfNextAvailablePlaceholderChar = i;\n                                            break;\n                                        }\n                                    }\n                                    if (indexOfNextAvailablePlaceholderChar !== null) {\n                                        conformedValue += rawValueChar;\n                                        rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n                                    } else {\n                                        i--;\n                                    }\n                                }\n                                continue placeholderLoop;\n                            } else {\n                                someCharsRejected = true;\n                            }\n                        }\n                    }\n                    if (suppressGuide === false) {\n                        conformedValue += placeholder.substr(i, placeholderLength);\n                    }\n                    break;\n                } else {\n                    conformedValue += charInPlaceholder;\n                }\n            }\n        if (suppressGuide && isAddition === false) {\n            let indexOfLastFilledPlaceholderChar = null;\n            for (let i = 0; i < conformedValue.length; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    indexOfLastFilledPlaceholderChar = i;\n                }\n            }\n            if (indexOfLastFilledPlaceholderChar !== null) {\n                conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n            } else {\n                conformedValue = emptyString;\n            }\n        }\n        return {\n            conformedValue,\n            meta: { someCharsRejected }\n        };\n    }\n\n\n    return textmask.conformToMask = conformToMask;\n    \n});\ndefine('skylark-textmask/createTextMaskInputElement',[\n    \"./textmask\",\n    './adjustCaretPosition',\n    './conformToMask',\n    './utilities',\n    './constants'\n], function (textmask,adjustCaretPosition, conformToMask, a,constants) {\n    'use strict';\n\n    const emptyString = '';\n    const strNone = 'none';\n    const strObject = 'object';\n    const isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n    const defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\n\n    function createTextMaskInputElement(config) {\n        const state = {\n            previousConformedValue: undefined,\n            previousPlaceholder: undefined\n        };\n        return {\n            state,\n            update(rawValue, {\n                inputElement,\n                mask: providedMask,\n                guide,\n                pipe,\n                placeholderChar = constants.placeholderChar,\n                keepCharPositions = false,\n                showMask = false\n            } = config) {\n                if (typeof rawValue === 'undefined') {\n                    rawValue = inputElement.value;\n                }\n                if (rawValue === state.previousConformedValue) {\n                    return;\n                }\n                if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n                    pipe = providedMask.pipe;\n                    providedMask = providedMask.mask;\n                }\n                let placeholder;\n                let mask;\n                if (providedMask instanceof Array) {\n                    placeholder = a.convertMaskToPlaceholder(providedMask, placeholderChar);\n                }\n                if (providedMask === false) {\n                    return;\n                }\n                const safeRawValue = getSafeRawValue(rawValue);\n                const {selectionEnd: currentCaretPosition} = inputElement;\n                const {previousConformedValue, previousPlaceholder} = state;\n                let caretTrapIndexes;\n                if (typeof providedMask === constants.strFunction) {\n                    mask = providedMask(safeRawValue, {\n                        currentCaretPosition,\n                        previousConformedValue,\n                        placeholderChar\n                    });\n                    if (mask === false) {\n                        return;\n                    }\n                    const {maskWithoutCaretTraps, indexes} = a.processCaretTraps(mask);\n                    mask = maskWithoutCaretTraps;\n                    caretTrapIndexes = indexes;\n                    placeholder = a.convertMaskToPlaceholder(mask, placeholderChar);\n                } else {\n                    mask = providedMask;\n                }\n                const conformToMaskConfig = {\n                    previousConformedValue,\n                    guide,\n                    placeholderChar,\n                    pipe,\n                    placeholder,\n                    currentCaretPosition,\n                    keepCharPositions\n                };\n                const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n                const piped = typeof pipe === constants.strFunction;\n                let pipeResults = {};\n                if (piped) {\n                    pipeResults = pipe(conformedValue, Object.assign({\n                        rawValue: safeRawValue\n                    },conformToMaskConfig));\n                    if (pipeResults === false) {\n                        pipeResults = {\n                            value: previousConformedValue,\n                            rejected: true\n                        };\n                    } else if (a.isString(pipeResults)) {\n                        pipeResults = { value: pipeResults };\n                    }\n                }\n                const finalConformedValue = piped ? pipeResults.value : conformedValue;\n                const adjustedCaretPosition = adjustCaretPosition({\n                    previousConformedValue,\n                    previousPlaceholder,\n                    conformedValue: finalConformedValue,\n                    placeholder,\n                    rawValue: safeRawValue,\n                    currentCaretPosition,\n                    placeholderChar,\n                    indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n                    caretTrapIndexes\n                });\n                const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n                const emptyValue = showMask ? placeholder : emptyString;\n                const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n                state.previousConformedValue = inputElementValue;\n                state.previousPlaceholder = placeholder;\n                if (inputElement.value === inputElementValue) {\n                    return;\n                }\n                inputElement.value = inputElementValue;\n                safeSetSelection(inputElement, adjustedCaretPosition);\n            }\n        };\n    };\n    function safeSetSelection(element, selectionPosition) {\n        if (document.activeElement === element) {\n            if (isAndroid) {\n                defer(() => element.setSelectionRange(selectionPosition, selectionPosition, strNone), 0);\n            } else {\n                element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n            }\n        }\n    }\n    function getSafeRawValue(inputValue) {\n        if (a.isString(inputValue)) {\n            return inputValue;\n        } else if (a.isNumber(inputValue)) {\n            return String(inputValue);\n        } else if (inputValue === undefined || inputValue === null) {\n            return emptyString;\n        } else {\n            throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value \" + `received was:\\n\\n ${ JSON.stringify(inputValue) }`);\n        }\n    }\n\n\n    return textmask.createTextMaskInputElement = createTextMaskInputElement;\n});\ndefine('skylark-textmask/maskInput',[\r\n    \"./textmask\",\r\n\t'./createTextMaskInputElement'\r\n],function (textmask,createTextMaskInputElement) {\r\n    'use strict';\r\n\r\n\r\n\tfunction maskInput(textMaskConfig) {\r\n\t  const {inputElement} = textMaskConfig\r\n\t  const textMaskInputElement = createTextMaskInputElement(textMaskConfig)\r\n\t  const inputHandler = ({target: {value}}) => textMaskInputElement.update(value)\r\n\r\n\t  inputElement.addEventListener('input', inputHandler)\r\n\r\n\t  textMaskInputElement.update(inputElement.value)\r\n\r\n\t  return {\r\n\t    textMaskInputElement,\r\n\r\n\t    destroy() {\r\n\t      inputElement.removeEventListener('input', inputHandler)\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\treturn textmask.maskInput = maskInput;\r\n\r\n}); \ndefine('skylark-textmask/main',[\n\t\"./textmask\",\n\t\"./maskInput\"\n],function (textmask) {\n    'use strict';\n\n\treturn textmask;\n\n}); \ndefine('skylark-textmask', ['skylark-textmask/main'], function (main) { return main; });\n\n"]}