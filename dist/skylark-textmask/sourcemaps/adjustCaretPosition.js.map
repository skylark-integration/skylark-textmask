{"version":3,"sources":["adjustCaretPosition.js"],"names":["define","defaultArray","previousConformedValue","previousPlaceholder","currentCaretPosition","conformedValue","rawValue","placeholderChar","placeholder","indexesOfPipedChars","caretTrapIndexes","length","rawValueLength","previousConformedValueLength","placeholderLength","conformedValueLength","editLength","isAddition","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","intersection","substr","split","filter","char","indexOf","previousLeftMaskChars","masklengthChanged","targetIsMaskMovingLeft","undefined","countTargetCharInPipedChars","map","index","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","i","lastPlaceholderChar"],"mappings":"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","file":"../adjustCaretPosition.js","sourcesContent":["define(function () {\n    'use strict';\n    const defaultArray = [];\n    const emptyString = '';\n    return function adjustCaretPosition({previousConformedValue = emptyString, previousPlaceholder = emptyString, currentCaretPosition = 0, conformedValue, rawValue, placeholderChar, placeholder, indexesOfPipedChars = defaultArray, caretTrapIndexes = defaultArray}) {\n        if (currentCaretPosition === 0 || !rawValue.length) {\n            return 0;\n        }\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const conformedValueLength = conformedValue.length;\n        const editLength = rawValueLength - previousConformedValueLength;\n        const isAddition = editLength > 0;\n        const isFirstRawValue = previousConformedValueLength === 0;\n        const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n        if (isPartialMultiCharEdit) {\n            return currentCaretPosition;\n        }\n        const possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n        let startingSearchIndex = 0;\n        let trackRightCharacter;\n        let targetChar;\n        if (possiblyHasRejectedChar) {\n            startingSearchIndex = currentCaretPosition - editLength;\n        } else {\n            const normalizedConformedValue = conformedValue.toLowerCase();\n            const normalizedRawValue = rawValue.toLowerCase();\n            const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString);\n            const intersection = leftHalfChars.filter(char => normalizedConformedValue.indexOf(char) !== -1);\n            targetChar = intersection[intersection.length - 1];\n            const previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n            const targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n            if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n                trackRightCharacter = true;\n                targetChar = rawValue[currentCaretPosition];\n            }\n            const pipedChars = indexesOfPipedChars.map(index => normalizedConformedValue[index]);\n            const countTargetCharInPipedChars = pipedChars.filter(char => char === targetChar).length;\n            const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n            const countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter((char, index) => char === targetChar && rawValue[index] !== char).length;\n            const requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (trackRightCharacter ? 1 : 0);\n            let numberOfEncounteredMatches = 0;\n            for (let i = 0; i < conformedValueLength; i++) {\n                const conformedValueChar = normalizedConformedValue[i];\n                startingSearchIndex = i + 1;\n                if (conformedValueChar === targetChar) {\n                    numberOfEncounteredMatches++;\n                }\n                if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n                    break;\n                }\n            }\n        }\n        if (isAddition) {\n            let lastPlaceholderChar = startingSearchIndex;\n            for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    lastPlaceholderChar = i;\n                }\n                if (placeholder[i] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === placeholderLength) {\n                    return lastPlaceholderChar;\n                }\n            }\n        } else {\n            if (trackRightCharacter) {\n                for (let i = startingSearchIndex - 1; i >= 0; i--) {\n                    if (conformedValue[i] === targetChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            } else {\n                for (let i = startingSearchIndex; i >= 0; i--) {\n                    if (placeholder[i - 1] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n    };\n});"]}