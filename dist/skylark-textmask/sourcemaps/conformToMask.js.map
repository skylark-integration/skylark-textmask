{"version":3,"sources":["conformToMask.js"],"names":["define","textmask","utilities","constants","emptyArray","emptyString","conformToMask","rawValue","mask","config","isArray","strFunction","Error","processCaretTraps","maskWithoutCaretTraps","guide","previousConformedValue","placeholderChar","placeholder","convertMaskToPlaceholder","currentCaretPosition","keepCharPositions","suppressGuide","undefined","rawValueLength","length","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","i","slice","rawValueArr","split","map","char","isNew","splice","conformedValue","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","shift","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","substr","indexOfLastFilledPlaceholderChar","meta"],"mappings":"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","file":"../conformToMask.js","sourcesContent":["define([\n    \"./textmask\",\n    './utilities',\n    './constants'\n], function (textmask,utilities,constants) {\n\n    const emptyArray = [];\n    const emptyString = '';\n\n    function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\n        if (!utilities.isArray(mask)) {\n            if (typeof mask === constants.strFunction) {\n                mask = mask(rawValue, config);\n                mask = utilities.processCaretTraps(mask).maskWithoutCaretTraps;\n            } else {\n                throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n            }\n        }\n        const {guide = true, previousConformedValue = emptyString, placeholderChar = constants.placeholderChar, placeholder = utilities.convertMaskToPlaceholder(mask, placeholderChar), currentCaretPosition, keepCharPositions} = config;\n        const suppressGuide = guide === false && previousConformedValue !== undefined;\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const maskLength = mask.length;\n        const editDistance = rawValueLength - previousConformedValueLength;\n        const isAddition = editDistance > 0;\n        const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0);\n        const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n        if (keepCharPositions === true && !isAddition) {\n            let compensatingPlaceholderChars = emptyString;\n            for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    compensatingPlaceholderChars += placeholderChar;\n                }\n            }\n            rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n        }\n        const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n            char,\n            isNew: i >= indexOfFirstChange && i < indexOfLastChange\n        }));\n        for (let i = rawValueLength - 1; i >= 0; i--) {\n            const {char} = rawValueArr[i];\n            if (char !== placeholderChar) {\n                const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n                if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n                    rawValueArr.splice(i, 1);\n                }\n            }\n        }\n        let conformedValue = emptyString;\n        let someCharsRejected = false;\n        placeholderLoop:\n            for (let i = 0; i < placeholderLength; i++) {\n                const charInPlaceholder = placeholder[i];\n                if (charInPlaceholder === placeholderChar) {\n                    if (rawValueArr.length > 0) {\n                        while (rawValueArr.length > 0) {\n                            const {\n                                char: rawValueChar,\n                                isNew\n                            } = rawValueArr.shift();\n                            if (rawValueChar === placeholderChar && suppressGuide !== true) {\n                                conformedValue += placeholderChar;\n                                continue placeholderLoop;\n                            } else if (mask[i].test(rawValueChar)) {\n                                if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString || guide === false || !isAddition) {\n                                    conformedValue += rawValueChar;\n                                } else {\n                                    const rawValueArrLength = rawValueArr.length;\n                                    let indexOfNextAvailablePlaceholderChar = null;\n                                    for (let i = 0; i < rawValueArrLength; i++) {\n                                        const charData = rawValueArr[i];\n                                        if (charData.char !== placeholderChar && charData.isNew === false) {\n                                            break;\n                                        }\n                                        if (charData.char === placeholderChar) {\n                                            indexOfNextAvailablePlaceholderChar = i;\n                                            break;\n                                        }\n                                    }\n                                    if (indexOfNextAvailablePlaceholderChar !== null) {\n                                        conformedValue += rawValueChar;\n                                        rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n                                    } else {\n                                        i--;\n                                    }\n                                }\n                                continue placeholderLoop;\n                            } else {\n                                someCharsRejected = true;\n                            }\n                        }\n                    }\n                    if (suppressGuide === false) {\n                        conformedValue += placeholder.substr(i, placeholderLength);\n                    }\n                    break;\n                } else {\n                    conformedValue += charInPlaceholder;\n                }\n            }\n        if (suppressGuide && isAddition === false) {\n            let indexOfLastFilledPlaceholderChar = null;\n            for (let i = 0; i < conformedValue.length; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    indexOfLastFilledPlaceholderChar = i;\n                }\n            }\n            if (indexOfLastFilledPlaceholderChar !== null) {\n                conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n            } else {\n                conformedValue = emptyString;\n            }\n        }\n        return {\n            conformedValue,\n            meta: { someCharsRejected }\n        };\n    }\n\n\n    return textmask.conformToMask = conformToMask;\n    \n});"]}