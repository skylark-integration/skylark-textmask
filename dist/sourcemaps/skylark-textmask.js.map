{"version":3,"sources":["skylark-textmask.js"],"names":["define","skylark","attach","textmask","defaultArray","emptyString","adjustCaretPosition","previousConformedValue","previousPlaceholder","currentCaretPosition","conformedValue","rawValue","placeholderChar","placeholder","indexesOfPipedChars","caretTrapIndexes","length","rawValueLength","previousConformedValueLength","placeholderLength","conformedValueLength","editLength","isAddition","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","normalizedRawValue","leftHalfChars","substr","split","intersection","filter","char","indexOf","previousLeftMaskChars","leftMaskChars","masklengthChanged","targetIsMaskMovingLeft","undefined","pipedChars","map","index","countTargetCharInPipedChars","countTargetCharInIntersection","countTargetCharInPlaceholder","requiredNumberOfMatches","numberOfEncounteredMatches","i","conformedValueChar","lastPlaceholderChar","strFunction","constants","emptyArray","isArray","value","Array","strCaretTrap","convertMaskToPlaceholder","mask","Error","JSON","stringify","RegExp","join","isString","String","isNumber","isNaN","isNil","processCaretTraps","indexes","indexOfCaretTrap","push","splice","maskWithoutCaretTraps","utilities","conformToMask","config","guide","keepCharPositions","suppressGuide","maskLength","editDistance","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","slice","rawValueArr","isNew","shouldOffset","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","shift","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","indexOfLastFilledPlaceholderChar","meta","a","strNone","strObject","isAndroid","navigator","userAgent","defer","requestAnimationFrame","setTimeout","createTextMaskInputElement","state","[object Object]","inputElement","providedMask","pipe","showMask","safeRawValue","inputValue","getSafeRawValue","selectionEnd","conformToMaskConfig","piped","pipeResults","Object","assign","rejected","finalConformedValue","adjustedCaretPosition","inputValueShouldBeEmpty","emptyValue","inputElementValue","element","selectionPosition","document","activeElement","setSelectionRange","maskInput","textMaskConfig","textMaskInputElement","inputHandler","target","update","addEventListener","removeEventListener","main"],"mappings":"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","file":"../skylark-textmask.js","sourcesContent":["define('skylark-textmask/textmask',[\r\n\t\"skylark-langx/skylark\"\r\n],function (skylark) {\r\n    'use strict';\r\n\r\n\treturn skylark.attach(\"intg.textmask\",{\r\n\t});\t\t\r\n\r\n}); \ndefine('skylark-textmask/adjustCaretPosition',[\n    \"./textmask\"\n],function (textmask) {\n    'use strict';\n    const defaultArray = [];\n    const emptyString = '';\n\n    function adjustCaretPosition({previousConformedValue = emptyString, previousPlaceholder = emptyString, currentCaretPosition = 0, conformedValue, rawValue, placeholderChar, placeholder, indexesOfPipedChars = defaultArray, caretTrapIndexes = defaultArray}) {\n        if (currentCaretPosition === 0 || !rawValue.length) {\n            return 0;\n        }\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const conformedValueLength = conformedValue.length;\n        const editLength = rawValueLength - previousConformedValueLength;\n        const isAddition = editLength > 0;\n        const isFirstRawValue = previousConformedValueLength === 0;\n        const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n        if (isPartialMultiCharEdit) {\n            return currentCaretPosition;\n        }\n        const possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n        let startingSearchIndex = 0;\n        let trackRightCharacter;\n        let targetChar;\n        if (possiblyHasRejectedChar) {\n            startingSearchIndex = currentCaretPosition - editLength;\n        } else {\n            const normalizedConformedValue = conformedValue.toLowerCase();\n            const normalizedRawValue = rawValue.toLowerCase();\n            const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString);\n            const intersection = leftHalfChars.filter(char => normalizedConformedValue.indexOf(char) !== -1);\n            targetChar = intersection[intersection.length - 1];\n            const previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n            const targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n            if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n                trackRightCharacter = true;\n                targetChar = rawValue[currentCaretPosition];\n            }\n            const pipedChars = indexesOfPipedChars.map(index => normalizedConformedValue[index]);\n            const countTargetCharInPipedChars = pipedChars.filter(char => char === targetChar).length;\n            const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n            const countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter((char, index) => char === targetChar && rawValue[index] !== char).length;\n            const requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (trackRightCharacter ? 1 : 0);\n            let numberOfEncounteredMatches = 0;\n            for (let i = 0; i < conformedValueLength; i++) {\n                const conformedValueChar = normalizedConformedValue[i];\n                startingSearchIndex = i + 1;\n                if (conformedValueChar === targetChar) {\n                    numberOfEncounteredMatches++;\n                }\n                if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n                    break;\n                }\n            }\n        }\n        if (isAddition) {\n            let lastPlaceholderChar = startingSearchIndex;\n            for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    lastPlaceholderChar = i;\n                }\n                if (placeholder[i] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === placeholderLength) {\n                    return lastPlaceholderChar;\n                }\n            }\n        } else {\n            if (trackRightCharacter) {\n                for (let i = startingSearchIndex - 1; i >= 0; i--) {\n                    if (conformedValue[i] === targetChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            } else {\n                for (let i = startingSearchIndex; i >= 0; i--) {\n                    if (placeholder[i - 1] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n\n    return textmask.adjustCaretPosition = adjustCaretPosition;\n});\ndefine('skylark-textmask/constants',[],function () {\n    'use strict';\n    const placeholderChar = '_';\n    const strFunction = 'function';\n    return {\n        placeholderChar: placeholderChar,\n        strFunction: strFunction\n    };\n});\ndefine('skylark-textmask/utilities',['./constants'], function (constants) {\n    'use strict';\n    const emptyArray = [];\n    function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = constants.placeholderChar) {\n        if (!isArray(mask)) {\n            throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\n        }\n        if (mask.indexOf(placeholderChar) !== -1) {\n            throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + `The placeholder character that was received is: ${ JSON.stringify(placeholderChar) }\\n\\n` + `The mask that was received is: ${ JSON.stringify(mask) }`);\n        }\n        return mask.map(char => {\n            return char instanceof RegExp ? placeholderChar : char;\n        }).join('');\n    }\n    function isArray(value) {\n        return Array.isArray && Array.isArray(value) || value instanceof Array;\n    }\n    function isString(value) {\n        return typeof value === 'string' || value instanceof String;\n    }\n    function isNumber(value) {\n        return typeof value === 'number' && value.length === undefined && !isNaN(value);\n    }\n    function isNil(value) {\n        return typeof value === 'undefined' || value === null;\n    }\n    const strCaretTrap = '[]';\n    function processCaretTraps(mask) {\n        const indexes = [];\n        let indexOfCaretTrap;\n        while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\n            indexes.push(indexOfCaretTrap);\n            mask.splice(indexOfCaretTrap, 1);\n        }\n        return {\n            maskWithoutCaretTraps: mask,\n            indexes\n        };\n    }\n    return {\n        convertMaskToPlaceholder: convertMaskToPlaceholder,\n        isArray: isArray,\n        isString: isString,\n        isNumber: isNumber,\n        isNil: isNil,\n        processCaretTraps: processCaretTraps\n    };\n});\ndefine('skylark-textmask/conformToMask',[\n    \"./textmask\",\n    './utilities',\n    './constants'\n], function (textmask,utilities,constants) {\n\n    const emptyArray = [];\n    const emptyString = '';\n\n    function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\n        if (!utilities.isArray(mask)) {\n            if (typeof mask === constants.strFunction) {\n                mask = mask(rawValue, config);\n                mask = utilities.processCaretTraps(mask).maskWithoutCaretTraps;\n            } else {\n                throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n            }\n        }\n        const {guide = true, previousConformedValue = emptyString, placeholderChar = constants.placeholderChar, placeholder = utilities.convertMaskToPlaceholder(mask, placeholderChar), currentCaretPosition, keepCharPositions} = config;\n        const suppressGuide = guide === false && previousConformedValue !== undefined;\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const maskLength = mask.length;\n        const editDistance = rawValueLength - previousConformedValueLength;\n        const isAddition = editDistance > 0;\n        const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0);\n        const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n        if (keepCharPositions === true && !isAddition) {\n            let compensatingPlaceholderChars = emptyString;\n            for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    compensatingPlaceholderChars += placeholderChar;\n                }\n            }\n            rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n        }\n        const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n            char,\n            isNew: i >= indexOfFirstChange && i < indexOfLastChange\n        }));\n        for (let i = rawValueLength - 1; i >= 0; i--) {\n            const {char} = rawValueArr[i];\n            if (char !== placeholderChar) {\n                const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n                if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n                    rawValueArr.splice(i, 1);\n                }\n            }\n        }\n        let conformedValue = emptyString;\n        let someCharsRejected = false;\n        placeholderLoop:\n            for (let i = 0; i < placeholderLength; i++) {\n                const charInPlaceholder = placeholder[i];\n                if (charInPlaceholder === placeholderChar) {\n                    if (rawValueArr.length > 0) {\n                        while (rawValueArr.length > 0) {\n                            const {\n                                char: rawValueChar,\n                                isNew\n                            } = rawValueArr.shift();\n                            if (rawValueChar === placeholderChar && suppressGuide !== true) {\n                                conformedValue += placeholderChar;\n                                continue placeholderLoop;\n                            } else if (mask[i].test(rawValueChar)) {\n                                if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString || guide === false || !isAddition) {\n                                    conformedValue += rawValueChar;\n                                } else {\n                                    const rawValueArrLength = rawValueArr.length;\n                                    let indexOfNextAvailablePlaceholderChar = null;\n                                    for (let i = 0; i < rawValueArrLength; i++) {\n                                        const charData = rawValueArr[i];\n                                        if (charData.char !== placeholderChar && charData.isNew === false) {\n                                            break;\n                                        }\n                                        if (charData.char === placeholderChar) {\n                                            indexOfNextAvailablePlaceholderChar = i;\n                                            break;\n                                        }\n                                    }\n                                    if (indexOfNextAvailablePlaceholderChar !== null) {\n                                        conformedValue += rawValueChar;\n                                        rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n                                    } else {\n                                        i--;\n                                    }\n                                }\n                                continue placeholderLoop;\n                            } else {\n                                someCharsRejected = true;\n                            }\n                        }\n                    }\n                    if (suppressGuide === false) {\n                        conformedValue += placeholder.substr(i, placeholderLength);\n                    }\n                    break;\n                } else {\n                    conformedValue += charInPlaceholder;\n                }\n            }\n        if (suppressGuide && isAddition === false) {\n            let indexOfLastFilledPlaceholderChar = null;\n            for (let i = 0; i < conformedValue.length; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    indexOfLastFilledPlaceholderChar = i;\n                }\n            }\n            if (indexOfLastFilledPlaceholderChar !== null) {\n                conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n            } else {\n                conformedValue = emptyString;\n            }\n        }\n        return {\n            conformedValue,\n            meta: { someCharsRejected }\n        };\n    }\n\n\n    return textmask.conformToMask = conformToMask;\n    \n});\ndefine('skylark-textmask/createTextMaskInputElement',[\n    \"./textmask\",\n    './adjustCaretPosition',\n    './conformToMask',\n    './utilities',\n    './constants'\n], function (textmask,adjustCaretPosition, conformToMask, a,constants) {\n    'use strict';\n\n    const emptyString = '';\n    const strNone = 'none';\n    const strObject = 'object';\n    const isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n    const defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\n\n    function createTextMaskInputElement(config) {\n        const state = {\n            previousConformedValue: undefined,\n            previousPlaceholder: undefined\n        };\n        return {\n            state,\n            update(rawValue, {\n                inputElement,\n                mask: providedMask,\n                guide,\n                pipe,\n                placeholderChar = constants.placeholderChar,\n                keepCharPositions = false,\n                showMask = false\n            } = config) {\n                if (typeof rawValue === 'undefined') {\n                    rawValue = inputElement.value;\n                }\n                if (rawValue === state.previousConformedValue) {\n                    return;\n                }\n                if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n                    pipe = providedMask.pipe;\n                    providedMask = providedMask.mask;\n                }\n                let placeholder;\n                let mask;\n                if (providedMask instanceof Array) {\n                    placeholder = a.convertMaskToPlaceholder(providedMask, placeholderChar);\n                }\n                if (providedMask === false) {\n                    return;\n                }\n                const safeRawValue = getSafeRawValue(rawValue);\n                const {selectionEnd: currentCaretPosition} = inputElement;\n                const {previousConformedValue, previousPlaceholder} = state;\n                let caretTrapIndexes;\n                if (typeof providedMask === constants.strFunction) {\n                    mask = providedMask(safeRawValue, {\n                        currentCaretPosition,\n                        previousConformedValue,\n                        placeholderChar\n                    });\n                    if (mask === false) {\n                        return;\n                    }\n                    const {maskWithoutCaretTraps, indexes} = a.processCaretTraps(mask);\n                    mask = maskWithoutCaretTraps;\n                    caretTrapIndexes = indexes;\n                    placeholder = a.convertMaskToPlaceholder(mask, placeholderChar);\n                } else {\n                    mask = providedMask;\n                }\n                const conformToMaskConfig = {\n                    previousConformedValue,\n                    guide,\n                    placeholderChar,\n                    pipe,\n                    placeholder,\n                    currentCaretPosition,\n                    keepCharPositions\n                };\n                const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n                const piped = typeof pipe === constants.strFunction;\n                let pipeResults = {};\n                if (piped) {\n                    pipeResults = pipe(conformedValue, Object.assign({\n                        rawValue: safeRawValue\n                    },conformToMaskConfig));\n                    if (pipeResults === false) {\n                        pipeResults = {\n                            value: previousConformedValue,\n                            rejected: true\n                        };\n                    } else if (a.isString(pipeResults)) {\n                        pipeResults = { value: pipeResults };\n                    }\n                }\n                const finalConformedValue = piped ? pipeResults.value : conformedValue;\n                const adjustedCaretPosition = adjustCaretPosition({\n                    previousConformedValue,\n                    previousPlaceholder,\n                    conformedValue: finalConformedValue,\n                    placeholder,\n                    rawValue: safeRawValue,\n                    currentCaretPosition,\n                    placeholderChar,\n                    indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n                    caretTrapIndexes\n                });\n                const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n                const emptyValue = showMask ? placeholder : emptyString;\n                const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n                state.previousConformedValue = inputElementValue;\n                state.previousPlaceholder = placeholder;\n                if (inputElement.value === inputElementValue) {\n                    return;\n                }\n                inputElement.value = inputElementValue;\n                safeSetSelection(inputElement, adjustedCaretPosition);\n            }\n        };\n    };\n    function safeSetSelection(element, selectionPosition) {\n        if (document.activeElement === element) {\n            if (isAndroid) {\n                defer(() => element.setSelectionRange(selectionPosition, selectionPosition, strNone), 0);\n            } else {\n                element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n            }\n        }\n    }\n    function getSafeRawValue(inputValue) {\n        if (a.isString(inputValue)) {\n            return inputValue;\n        } else if (a.isNumber(inputValue)) {\n            return String(inputValue);\n        } else if (inputValue === undefined || inputValue === null) {\n            return emptyString;\n        } else {\n            throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value \" + `received was:\\n\\n ${ JSON.stringify(inputValue) }`);\n        }\n    }\n\n\n    return textmask.createTextMaskInputElement = createTextMaskInputElement;\n});\ndefine('skylark-textmask/maskInput',[\r\n    \"./textmask\",\r\n\t'./createTextMaskInputElement'\r\n],function (textmask,createTextMaskInputElement) {\r\n    'use strict';\r\n\r\n\r\n\tfunction maskInput(textMaskConfig) {\r\n\t  const {inputElement} = textMaskConfig\r\n\t  const textMaskInputElement = createTextMaskInputElement(textMaskConfig)\r\n\t  const inputHandler = ({target: {value}}) => textMaskInputElement.update(value)\r\n\r\n\t  inputElement.addEventListener('input', inputHandler)\r\n\r\n\t  textMaskInputElement.update(inputElement.value)\r\n\r\n\t  return {\r\n\t    textMaskInputElement,\r\n\r\n\t    destroy() {\r\n\t      inputElement.removeEventListener('input', inputHandler)\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\treturn textmask.maskInput = maskInput;\r\n\r\n}); \ndefine('skylark-textmask/main',[\n\t\"./textmask\",\n\t\"./maskInput\"\n],function (textmask) {\n    'use strict';\n\n\treturn textmask;\n\n}); \ndefine('skylark-textmask', ['skylark-textmask/main'], function (main) { return main; });\n\n"]}