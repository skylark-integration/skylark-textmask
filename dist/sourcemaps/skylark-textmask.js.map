{"version":3,"sources":["skylark-textmask.js"],"names":["define","placeholderChar","strFunction","defaultPlaceholderChar","emptyArray","isArray","value","Array","strCaretTrap","convertMaskToPlaceholder","mask","Error","indexOf","JSON","stringify","map","char","RegExp","join","isString","String","isNumber","undefined","length","isNaN","isNil","processCaretTraps","indexes","indexOfCaretTrap","push","splice","maskWithoutCaretTraps","a","b","emptyString","rawValue","config","guide","previousConformedValue","placeholder","currentCaretPosition","keepCharPositions","suppressGuide","rawValueLength","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","i","slice","rawValueArr","split","isNew","shouldOffset","conformedValue","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","shift","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","substr","indexOfLastFilledPlaceholderChar","meta","defaultArray","previousPlaceholder","indexesOfPipedChars","caretTrapIndexes","conformedValueLength","editLength","isFirstRawValue","isPartialMultiCharEdit","possiblyHasRejectedChar","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","normalizedRawValue","leftHalfChars","intersection","filter","previousLeftMaskChars","leftMaskChars","masklengthChanged","targetIsMaskMovingLeft","pipedChars","index","countTargetCharInPipedChars","countTargetCharInIntersection","countTargetCharInPlaceholder","requiredNumberOfMatches","numberOfEncounteredMatches","conformedValueChar","lastPlaceholderChar","adjustCaretPosition","conformToMask","strNone","isAndroid","navigator","userAgent","defer","requestAnimationFrame","setTimeout","state","[object Object]","inputElement","providedMask","pipe","showMask","safeRawValue","inputValue","getSafeRawValue","selectionEnd","conformToMaskConfig","piped","pipeResults","Object","assign","rejected","finalConformedValue","adjustedCaretPosition","inputValueShouldBeEmpty","emptyValue","inputElementValue","element","selectionPosition","document","activeElement","setSelectionRange","skylark","createTextMaskInputElement","attach","main"],"mappings":"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","file":"../skylark-textmask.js","sourcesContent":["define('skylark-textmask/constants',[],function () {\n    'use strict';\n    const placeholderChar = '_';\n    const strFunction = 'function';\n    return {\n        placeholderChar: placeholderChar,\n        strFunction: strFunction\n    };\n});\ndefine('skylark-textmask/utilities',['./constants'], function (defaultPlaceholderChar) {\n    'use strict';\n    const emptyArray = [];\n    function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = defaultPlaceholderChar) {\n        if (!isArray(mask)) {\n            throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\n        }\n        if (mask.indexOf(placeholderChar) !== -1) {\n            throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + `The placeholder character that was received is: ${ JSON.stringify(placeholderChar) }\\n\\n` + `The mask that was received is: ${ JSON.stringify(mask) }`);\n        }\n        return mask.map(char => {\n            return char instanceof RegExp ? placeholderChar : char;\n        }).join('');\n    }\n    function isArray(value) {\n        return Array.isArray && Array.isArray(value) || value instanceof Array;\n    }\n    function isString(value) {\n        return typeof value === 'string' || value instanceof String;\n    }\n    function isNumber(value) {\n        return typeof value === 'number' && value.length === undefined && !isNaN(value);\n    }\n    function isNil(value) {\n        return typeof value === 'undefined' || value === null;\n    }\n    const strCaretTrap = '[]';\n    function processCaretTraps(mask) {\n        const indexes = [];\n        let indexOfCaretTrap;\n        while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\n            indexes.push(indexOfCaretTrap);\n            mask.splice(indexOfCaretTrap, 1);\n        }\n        return {\n            maskWithoutCaretTraps: mask,\n            indexes\n        };\n    }\n    return {\n        convertMaskToPlaceholder: convertMaskToPlaceholder,\n        isArray: isArray,\n        isString: isString,\n        isNumber: isNumber,\n        isNil: isNil,\n        processCaretTraps: processCaretTraps\n    };\n});\ndefine('skylark-textmask/conformToMask',[\n    './utilities',\n    './constants',\n    './constants'\n], function (a, defaultPlaceholderChar, b) {\n    'use strict';\n    const emptyArray = [];\n    const emptyString = '';\n    return function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\n        if (!a.isArray(mask)) {\n            if (typeof mask === b.strFunction) {\n                mask = mask(rawValue, config);\n                mask = a.processCaretTraps(mask).maskWithoutCaretTraps;\n            } else {\n                throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n            }\n        }\n        const {guide = true, previousConformedValue = emptyString, placeholderChar = defaultPlaceholderChar, placeholder = a.convertMaskToPlaceholder(mask, placeholderChar), currentCaretPosition, keepCharPositions} = config;\n        const suppressGuide = guide === false && previousConformedValue !== undefined;\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const maskLength = mask.length;\n        const editDistance = rawValueLength - previousConformedValueLength;\n        const isAddition = editDistance > 0;\n        const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0);\n        const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n        if (keepCharPositions === true && !isAddition) {\n            let compensatingPlaceholderChars = emptyString;\n            for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    compensatingPlaceholderChars += placeholderChar;\n                }\n            }\n            rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n        }\n        const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n            char,\n            isNew: i >= indexOfFirstChange && i < indexOfLastChange\n        }));\n        for (let i = rawValueLength - 1; i >= 0; i--) {\n            const {char} = rawValueArr[i];\n            if (char !== placeholderChar) {\n                const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n                if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n                    rawValueArr.splice(i, 1);\n                }\n            }\n        }\n        let conformedValue = emptyString;\n        let someCharsRejected = false;\n        placeholderLoop:\n            for (let i = 0; i < placeholderLength; i++) {\n                const charInPlaceholder = placeholder[i];\n                if (charInPlaceholder === placeholderChar) {\n                    if (rawValueArr.length > 0) {\n                        while (rawValueArr.length > 0) {\n                            const {\n                                char: rawValueChar,\n                                isNew\n                            } = rawValueArr.shift();\n                            if (rawValueChar === placeholderChar && suppressGuide !== true) {\n                                conformedValue += placeholderChar;\n                                continue placeholderLoop;\n                            } else if (mask[i].test(rawValueChar)) {\n                                if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString || guide === false || !isAddition) {\n                                    conformedValue += rawValueChar;\n                                } else {\n                                    const rawValueArrLength = rawValueArr.length;\n                                    let indexOfNextAvailablePlaceholderChar = null;\n                                    for (let i = 0; i < rawValueArrLength; i++) {\n                                        const charData = rawValueArr[i];\n                                        if (charData.char !== placeholderChar && charData.isNew === false) {\n                                            break;\n                                        }\n                                        if (charData.char === placeholderChar) {\n                                            indexOfNextAvailablePlaceholderChar = i;\n                                            break;\n                                        }\n                                    }\n                                    if (indexOfNextAvailablePlaceholderChar !== null) {\n                                        conformedValue += rawValueChar;\n                                        rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n                                    } else {\n                                        i--;\n                                    }\n                                }\n                                continue placeholderLoop;\n                            } else {\n                                someCharsRejected = true;\n                            }\n                        }\n                    }\n                    if (suppressGuide === false) {\n                        conformedValue += placeholder.substr(i, placeholderLength);\n                    }\n                    break;\n                } else {\n                    conformedValue += charInPlaceholder;\n                }\n            }\n        if (suppressGuide && isAddition === false) {\n            let indexOfLastFilledPlaceholderChar = null;\n            for (let i = 0; i < conformedValue.length; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    indexOfLastFilledPlaceholderChar = i;\n                }\n            }\n            if (indexOfLastFilledPlaceholderChar !== null) {\n                conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n            } else {\n                conformedValue = emptyString;\n            }\n        }\n        return {\n            conformedValue,\n            meta: { someCharsRejected }\n        };\n    };\n});\ndefine('skylark-textmask/adjustCaretPosition',[],function () {\n    'use strict';\n    const defaultArray = [];\n    const emptyString = '';\n    return function adjustCaretPosition({previousConformedValue = emptyString, previousPlaceholder = emptyString, currentCaretPosition = 0, conformedValue, rawValue, placeholderChar, placeholder, indexesOfPipedChars = defaultArray, caretTrapIndexes = defaultArray}) {\n        if (currentCaretPosition === 0 || !rawValue.length) {\n            return 0;\n        }\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const conformedValueLength = conformedValue.length;\n        const editLength = rawValueLength - previousConformedValueLength;\n        const isAddition = editLength > 0;\n        const isFirstRawValue = previousConformedValueLength === 0;\n        const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n        if (isPartialMultiCharEdit) {\n            return currentCaretPosition;\n        }\n        const possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n        let startingSearchIndex = 0;\n        let trackRightCharacter;\n        let targetChar;\n        if (possiblyHasRejectedChar) {\n            startingSearchIndex = currentCaretPosition - editLength;\n        } else {\n            const normalizedConformedValue = conformedValue.toLowerCase();\n            const normalizedRawValue = rawValue.toLowerCase();\n            const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString);\n            const intersection = leftHalfChars.filter(char => normalizedConformedValue.indexOf(char) !== -1);\n            targetChar = intersection[intersection.length - 1];\n            const previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n            const targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n            if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n                trackRightCharacter = true;\n                targetChar = rawValue[currentCaretPosition];\n            }\n            const pipedChars = indexesOfPipedChars.map(index => normalizedConformedValue[index]);\n            const countTargetCharInPipedChars = pipedChars.filter(char => char === targetChar).length;\n            const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n            const countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter((char, index) => char === targetChar && rawValue[index] !== char).length;\n            const requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (trackRightCharacter ? 1 : 0);\n            let numberOfEncounteredMatches = 0;\n            for (let i = 0; i < conformedValueLength; i++) {\n                const conformedValueChar = normalizedConformedValue[i];\n                startingSearchIndex = i + 1;\n                if (conformedValueChar === targetChar) {\n                    numberOfEncounteredMatches++;\n                }\n                if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n                    break;\n                }\n            }\n        }\n        if (isAddition) {\n            let lastPlaceholderChar = startingSearchIndex;\n            for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    lastPlaceholderChar = i;\n                }\n                if (placeholder[i] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === placeholderLength) {\n                    return lastPlaceholderChar;\n                }\n            }\n        } else {\n            if (trackRightCharacter) {\n                for (let i = startingSearchIndex - 1; i >= 0; i--) {\n                    if (conformedValue[i] === targetChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            } else {\n                for (let i = startingSearchIndex; i >= 0; i--) {\n                    if (placeholder[i - 1] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n    };\n});\ndefine('skylark-textmask/createTextMaskInputElement',[\n    './adjustCaretPosition',\n    './conformToMask',\n    './utilities',\n    './constants',\n    './constants'\n], function (adjustCaretPosition, conformToMask, a, defaultPlaceholderChar, b) {\n    'use strict';\n    const emptyString = '';\n    const strNone = 'none';\n    const strObject = 'object';\n    const isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n    const defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\n    return function createTextMaskInputElement(config) {\n        const state = {\n            previousConformedValue: undefined,\n            previousPlaceholder: undefined\n        };\n        return {\n            state,\n            update(rawValue, {\n                inputElement,\n                mask: providedMask,\n                guide,\n                pipe,\n                placeholderChar = defaultPlaceholderChar,\n                keepCharPositions = false,\n                showMask = false\n            } = config) {\n                if (typeof rawValue === 'undefined') {\n                    rawValue = inputElement.value;\n                }\n                if (rawValue === state.previousConformedValue) {\n                    return;\n                }\n                if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n                    pipe = providedMask.pipe;\n                    providedMask = providedMask.mask;\n                }\n                let placeholder;\n                let mask;\n                if (providedMask instanceof Array) {\n                    placeholder = a.convertMaskToPlaceholder(providedMask, placeholderChar);\n                }\n                if (providedMask === false) {\n                    return;\n                }\n                const safeRawValue = getSafeRawValue(rawValue);\n                const {selectionEnd: currentCaretPosition} = inputElement;\n                const {previousConformedValue, previousPlaceholder} = state;\n                let caretTrapIndexes;\n                if (typeof providedMask === b.strFunction) {\n                    mask = providedMask(safeRawValue, {\n                        currentCaretPosition,\n                        previousConformedValue,\n                        placeholderChar\n                    });\n                    if (mask === false) {\n                        return;\n                    }\n                    const {maskWithoutCaretTraps, indexes} = a.processCaretTraps(mask);\n                    mask = maskWithoutCaretTraps;\n                    caretTrapIndexes = indexes;\n                    placeholder = a.convertMaskToPlaceholder(mask, placeholderChar);\n                } else {\n                    mask = providedMask;\n                }\n                const conformToMaskConfig = {\n                    previousConformedValue,\n                    guide,\n                    placeholderChar,\n                    pipe,\n                    placeholder,\n                    currentCaretPosition,\n                    keepCharPositions\n                };\n                const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n                const piped = typeof pipe === b.strFunction;\n                let pipeResults = {};\n                if (piped) {\n                    pipeResults = pipe(conformedValue, Object.assign({\n                        rawValue: safeRawValue\n                    },conformToMaskConfig));\n                    if (pipeResults === false) {\n                        pipeResults = {\n                            value: previousConformedValue,\n                            rejected: true\n                        };\n                    } else if (a.isString(pipeResults)) {\n                        pipeResults = { value: pipeResults };\n                    }\n                }\n                const finalConformedValue = piped ? pipeResults.value : conformedValue;\n                const adjustedCaretPosition = adjustCaretPosition({\n                    previousConformedValue,\n                    previousPlaceholder,\n                    conformedValue: finalConformedValue,\n                    placeholder,\n                    rawValue: safeRawValue,\n                    currentCaretPosition,\n                    placeholderChar,\n                    indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n                    caretTrapIndexes\n                });\n                const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n                const emptyValue = showMask ? placeholder : emptyString;\n                const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n                state.previousConformedValue = inputElementValue;\n                state.previousPlaceholder = placeholder;\n                if (inputElement.value === inputElementValue) {\n                    return;\n                }\n                inputElement.value = inputElementValue;\n                safeSetSelection(inputElement, adjustedCaretPosition);\n            }\n        };\n    };\n    function safeSetSelection(element, selectionPosition) {\n        if (document.activeElement === element) {\n            if (isAndroid) {\n                defer(() => element.setSelectionRange(selectionPosition, selectionPosition, strNone), 0);\n            } else {\n                element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n            }\n        }\n    }\n    function getSafeRawValue(inputValue) {\n        if (a.isString(inputValue)) {\n            return inputValue;\n        } else if (a.isNumber(inputValue)) {\n            return String(inputValue);\n        } else if (inputValue === undefined || inputValue === null) {\n            return emptyString;\n        } else {\n            throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value \" + `received was:\\n\\n ${ JSON.stringify(inputValue) }`);\n        }\n    }\n});\ndefine('skylark-textmask/main',[\n\t\"skylark-langx/skylark\",\n\t'./conformToMask',\n\t'./adjustCaretPosition',\n\t'./createTextMaskInputElement'\n],function (skylark,conformToMask,adjustCaretPosition,createTextMaskInputElement) {\n\n    'use strict';\n\n    return skylark.attach(\"intg.textmask\",{\n        conformToMask,\n        adjustCaretPosition,\n        createTextMaskInputElement\n    });\n}); \ndefine('skylark-textmask', ['skylark-textmask/main'], function (main) { return main; });\n\n"]}