{"version":3,"sources":["skylark-textmask-all.js"],"names":["define","obj1","path","obj2","split","length","ns","i","name","_attach","skylark","attach","obj","main","placeholderChar","strFunction","defaultPlaceholderChar","emptyArray","isArray","value","Array","strCaretTrap","convertMaskToPlaceholder","mask","Error","indexOf","JSON","stringify","map","char","RegExp","join","isString","String","isNumber","undefined","isNaN","isNil","processCaretTraps","indexes","indexOfCaretTrap","push","splice","maskWithoutCaretTraps","a","b","emptyString","rawValue","config","guide","previousConformedValue","placeholder","currentCaretPosition","keepCharPositions","suppressGuide","rawValueLength","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","slice","rawValueArr","isNew","shouldOffset","conformedValue","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","shift","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","substr","indexOfLastFilledPlaceholderChar","meta","defaultArray","previousPlaceholder","indexesOfPipedChars","caretTrapIndexes","conformedValueLength","editLength","isFirstRawValue","isPartialMultiCharEdit","possiblyHasRejectedChar","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","normalizedRawValue","leftHalfChars","intersection","filter","previousLeftMaskChars","leftMaskChars","masklengthChanged","targetIsMaskMovingLeft","pipedChars","index","countTargetCharInPipedChars","countTargetCharInIntersection","countTargetCharInPlaceholder","requiredNumberOfMatches","numberOfEncounteredMatches","conformedValueChar","lastPlaceholderChar","adjustCaretPosition","conformToMask","strNone","isAndroid","navigator","userAgent","defer","requestAnimationFrame","setTimeout","state","[object Object]","inputElement","providedMask","pipe","showMask","safeRawValue","inputValue","getSafeRawValue","selectionEnd","conformToMaskConfig","piped","pipeResults","Object","assign","rejected","finalConformedValue","adjustedCaretPosition","inputValueShouldBeEmpty","emptyValue","inputElementValue","element","selectionPosition","document","activeElement","setSelectionRange","createTextMaskInputElement"],"mappings":"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","file":"../skylark-textmask-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        return ns[name] = obj2;\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var skylark = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(skylark,path,obj);\r\n    \t}\r\n    };\r\n    return skylark;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-langx/skylark',[\r\n    \"skylark-langx-ns\"\r\n], function(ns) {\r\n\treturn ns;\r\n});\r\n\ndefine('skylark-textmask/constants',[],function () {\n    'use strict';\n    const placeholderChar = '_';\n    const strFunction = 'function';\n    return {\n        placeholderChar: placeholderChar,\n        strFunction: strFunction\n    };\n});\ndefine('skylark-textmask/utilities',['./constants'], function (defaultPlaceholderChar) {\n    'use strict';\n    const emptyArray = [];\n    function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = defaultPlaceholderChar) {\n        if (!isArray(mask)) {\n            throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\n        }\n        if (mask.indexOf(placeholderChar) !== -1) {\n            throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + `The placeholder character that was received is: ${ JSON.stringify(placeholderChar) }\\n\\n` + `The mask that was received is: ${ JSON.stringify(mask) }`);\n        }\n        return mask.map(char => {\n            return char instanceof RegExp ? placeholderChar : char;\n        }).join('');\n    }\n    function isArray(value) {\n        return Array.isArray && Array.isArray(value) || value instanceof Array;\n    }\n    function isString(value) {\n        return typeof value === 'string' || value instanceof String;\n    }\n    function isNumber(value) {\n        return typeof value === 'number' && value.length === undefined && !isNaN(value);\n    }\n    function isNil(value) {\n        return typeof value === 'undefined' || value === null;\n    }\n    const strCaretTrap = '[]';\n    function processCaretTraps(mask) {\n        const indexes = [];\n        let indexOfCaretTrap;\n        while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\n            indexes.push(indexOfCaretTrap);\n            mask.splice(indexOfCaretTrap, 1);\n        }\n        return {\n            maskWithoutCaretTraps: mask,\n            indexes\n        };\n    }\n    return {\n        convertMaskToPlaceholder: convertMaskToPlaceholder,\n        isArray: isArray,\n        isString: isString,\n        isNumber: isNumber,\n        isNil: isNil,\n        processCaretTraps: processCaretTraps\n    };\n});\ndefine('skylark-textmask/conformToMask',[\n    './utilities',\n    './constants',\n    './constants'\n], function (a, defaultPlaceholderChar, b) {\n    'use strict';\n    const emptyArray = [];\n    const emptyString = '';\n    return function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\n        if (!a.isArray(mask)) {\n            if (typeof mask === b.strFunction) {\n                mask = mask(rawValue, config);\n                mask = a.processCaretTraps(mask).maskWithoutCaretTraps;\n            } else {\n                throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n            }\n        }\n        const {guide = true, previousConformedValue = emptyString, placeholderChar = defaultPlaceholderChar, placeholder = a.convertMaskToPlaceholder(mask, placeholderChar), currentCaretPosition, keepCharPositions} = config;\n        const suppressGuide = guide === false && previousConformedValue !== undefined;\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const maskLength = mask.length;\n        const editDistance = rawValueLength - previousConformedValueLength;\n        const isAddition = editDistance > 0;\n        const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0);\n        const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n        if (keepCharPositions === true && !isAddition) {\n            let compensatingPlaceholderChars = emptyString;\n            for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    compensatingPlaceholderChars += placeholderChar;\n                }\n            }\n            rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n        }\n        const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n            char,\n            isNew: i >= indexOfFirstChange && i < indexOfLastChange\n        }));\n        for (let i = rawValueLength - 1; i >= 0; i--) {\n            const {char} = rawValueArr[i];\n            if (char !== placeholderChar) {\n                const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n                if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n                    rawValueArr.splice(i, 1);\n                }\n            }\n        }\n        let conformedValue = emptyString;\n        let someCharsRejected = false;\n        placeholderLoop:\n            for (let i = 0; i < placeholderLength; i++) {\n                const charInPlaceholder = placeholder[i];\n                if (charInPlaceholder === placeholderChar) {\n                    if (rawValueArr.length > 0) {\n                        while (rawValueArr.length > 0) {\n                            const {\n                                char: rawValueChar,\n                                isNew\n                            } = rawValueArr.shift();\n                            if (rawValueChar === placeholderChar && suppressGuide !== true) {\n                                conformedValue += placeholderChar;\n                                continue placeholderLoop;\n                            } else if (mask[i].test(rawValueChar)) {\n                                if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString || guide === false || !isAddition) {\n                                    conformedValue += rawValueChar;\n                                } else {\n                                    const rawValueArrLength = rawValueArr.length;\n                                    let indexOfNextAvailablePlaceholderChar = null;\n                                    for (let i = 0; i < rawValueArrLength; i++) {\n                                        const charData = rawValueArr[i];\n                                        if (charData.char !== placeholderChar && charData.isNew === false) {\n                                            break;\n                                        }\n                                        if (charData.char === placeholderChar) {\n                                            indexOfNextAvailablePlaceholderChar = i;\n                                            break;\n                                        }\n                                    }\n                                    if (indexOfNextAvailablePlaceholderChar !== null) {\n                                        conformedValue += rawValueChar;\n                                        rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n                                    } else {\n                                        i--;\n                                    }\n                                }\n                                continue placeholderLoop;\n                            } else {\n                                someCharsRejected = true;\n                            }\n                        }\n                    }\n                    if (suppressGuide === false) {\n                        conformedValue += placeholder.substr(i, placeholderLength);\n                    }\n                    break;\n                } else {\n                    conformedValue += charInPlaceholder;\n                }\n            }\n        if (suppressGuide && isAddition === false) {\n            let indexOfLastFilledPlaceholderChar = null;\n            for (let i = 0; i < conformedValue.length; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    indexOfLastFilledPlaceholderChar = i;\n                }\n            }\n            if (indexOfLastFilledPlaceholderChar !== null) {\n                conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n            } else {\n                conformedValue = emptyString;\n            }\n        }\n        return {\n            conformedValue,\n            meta: { someCharsRejected }\n        };\n    };\n});\ndefine('skylark-textmask/adjustCaretPosition',[],function () {\n    'use strict';\n    const defaultArray = [];\n    const emptyString = '';\n    return function adjustCaretPosition({previousConformedValue = emptyString, previousPlaceholder = emptyString, currentCaretPosition = 0, conformedValue, rawValue, placeholderChar, placeholder, indexesOfPipedChars = defaultArray, caretTrapIndexes = defaultArray}) {\n        if (currentCaretPosition === 0 || !rawValue.length) {\n            return 0;\n        }\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const conformedValueLength = conformedValue.length;\n        const editLength = rawValueLength - previousConformedValueLength;\n        const isAddition = editLength > 0;\n        const isFirstRawValue = previousConformedValueLength === 0;\n        const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n        if (isPartialMultiCharEdit) {\n            return currentCaretPosition;\n        }\n        const possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n        let startingSearchIndex = 0;\n        let trackRightCharacter;\n        let targetChar;\n        if (possiblyHasRejectedChar) {\n            startingSearchIndex = currentCaretPosition - editLength;\n        } else {\n            const normalizedConformedValue = conformedValue.toLowerCase();\n            const normalizedRawValue = rawValue.toLowerCase();\n            const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString);\n            const intersection = leftHalfChars.filter(char => normalizedConformedValue.indexOf(char) !== -1);\n            targetChar = intersection[intersection.length - 1];\n            const previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n            const targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n            if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n                trackRightCharacter = true;\n                targetChar = rawValue[currentCaretPosition];\n            }\n            const pipedChars = indexesOfPipedChars.map(index => normalizedConformedValue[index]);\n            const countTargetCharInPipedChars = pipedChars.filter(char => char === targetChar).length;\n            const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n            const countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter((char, index) => char === targetChar && rawValue[index] !== char).length;\n            const requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (trackRightCharacter ? 1 : 0);\n            let numberOfEncounteredMatches = 0;\n            for (let i = 0; i < conformedValueLength; i++) {\n                const conformedValueChar = normalizedConformedValue[i];\n                startingSearchIndex = i + 1;\n                if (conformedValueChar === targetChar) {\n                    numberOfEncounteredMatches++;\n                }\n                if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n                    break;\n                }\n            }\n        }\n        if (isAddition) {\n            let lastPlaceholderChar = startingSearchIndex;\n            for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    lastPlaceholderChar = i;\n                }\n                if (placeholder[i] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === placeholderLength) {\n                    return lastPlaceholderChar;\n                }\n            }\n        } else {\n            if (trackRightCharacter) {\n                for (let i = startingSearchIndex - 1; i >= 0; i--) {\n                    if (conformedValue[i] === targetChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            } else {\n                for (let i = startingSearchIndex; i >= 0; i--) {\n                    if (placeholder[i - 1] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n    };\n});\ndefine('skylark-textmask/createTextMaskInputElement',[\n    './adjustCaretPosition',\n    './conformToMask',\n    './utilities',\n    './constants',\n    './constants'\n], function (adjustCaretPosition, conformToMask, a, defaultPlaceholderChar, b) {\n    'use strict';\n    const emptyString = '';\n    const strNone = 'none';\n    const strObject = 'object';\n    const isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n    const defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\n    return function createTextMaskInputElement(config) {\n        const state = {\n            previousConformedValue: undefined,\n            previousPlaceholder: undefined\n        };\n        return {\n            state,\n            update(rawValue, {\n                inputElement,\n                mask: providedMask,\n                guide,\n                pipe,\n                placeholderChar = defaultPlaceholderChar,\n                keepCharPositions = false,\n                showMask = false\n            } = config) {\n                if (typeof rawValue === 'undefined') {\n                    rawValue = inputElement.value;\n                }\n                if (rawValue === state.previousConformedValue) {\n                    return;\n                }\n                if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n                    pipe = providedMask.pipe;\n                    providedMask = providedMask.mask;\n                }\n                let placeholder;\n                let mask;\n                if (providedMask instanceof Array) {\n                    placeholder = a.convertMaskToPlaceholder(providedMask, placeholderChar);\n                }\n                if (providedMask === false) {\n                    return;\n                }\n                const safeRawValue = getSafeRawValue(rawValue);\n                const {selectionEnd: currentCaretPosition} = inputElement;\n                const {previousConformedValue, previousPlaceholder} = state;\n                let caretTrapIndexes;\n                if (typeof providedMask === b.strFunction) {\n                    mask = providedMask(safeRawValue, {\n                        currentCaretPosition,\n                        previousConformedValue,\n                        placeholderChar\n                    });\n                    if (mask === false) {\n                        return;\n                    }\n                    const {maskWithoutCaretTraps, indexes} = a.processCaretTraps(mask);\n                    mask = maskWithoutCaretTraps;\n                    caretTrapIndexes = indexes;\n                    placeholder = a.convertMaskToPlaceholder(mask, placeholderChar);\n                } else {\n                    mask = providedMask;\n                }\n                const conformToMaskConfig = {\n                    previousConformedValue,\n                    guide,\n                    placeholderChar,\n                    pipe,\n                    placeholder,\n                    currentCaretPosition,\n                    keepCharPositions\n                };\n                const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n                const piped = typeof pipe === b.strFunction;\n                let pipeResults = {};\n                if (piped) {\n                    pipeResults = pipe(conformedValue, Object.assign({\n                        rawValue: safeRawValue\n                    },conformToMaskConfig));\n                    if (pipeResults === false) {\n                        pipeResults = {\n                            value: previousConformedValue,\n                            rejected: true\n                        };\n                    } else if (a.isString(pipeResults)) {\n                        pipeResults = { value: pipeResults };\n                    }\n                }\n                const finalConformedValue = piped ? pipeResults.value : conformedValue;\n                const adjustedCaretPosition = adjustCaretPosition({\n                    previousConformedValue,\n                    previousPlaceholder,\n                    conformedValue: finalConformedValue,\n                    placeholder,\n                    rawValue: safeRawValue,\n                    currentCaretPosition,\n                    placeholderChar,\n                    indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n                    caretTrapIndexes\n                });\n                const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n                const emptyValue = showMask ? placeholder : emptyString;\n                const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n                state.previousConformedValue = inputElementValue;\n                state.previousPlaceholder = placeholder;\n                if (inputElement.value === inputElementValue) {\n                    return;\n                }\n                inputElement.value = inputElementValue;\n                safeSetSelection(inputElement, adjustedCaretPosition);\n            }\n        };\n    };\n    function safeSetSelection(element, selectionPosition) {\n        if (document.activeElement === element) {\n            if (isAndroid) {\n                defer(() => element.setSelectionRange(selectionPosition, selectionPosition, strNone), 0);\n            } else {\n                element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n            }\n        }\n    }\n    function getSafeRawValue(inputValue) {\n        if (a.isString(inputValue)) {\n            return inputValue;\n        } else if (a.isNumber(inputValue)) {\n            return String(inputValue);\n        } else if (inputValue === undefined || inputValue === null) {\n            return emptyString;\n        } else {\n            throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value \" + `received was:\\n\\n ${ JSON.stringify(inputValue) }`);\n        }\n    }\n});\ndefine('skylark-textmask/main',[\n\t\"skylark-langx/skylark\",\n\t'./conformToMask',\n\t'./adjustCaretPosition',\n\t'./createTextMaskInputElement'\n],function (skylark,conformToMask,adjustCaretPosition,createTextMaskInputElement) {\n\n    'use strict';\n\n    return skylark.attach(\"intg.textmask\",{\n        conformToMask,\n        adjustCaretPosition,\n        createTextMaskInputElement\n    });\n}); \ndefine('skylark-textmask', ['skylark-textmask/main'], function (main) { return main; });\n\n"]}