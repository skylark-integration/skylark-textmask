{"version":3,"sources":["skylark-textmask-all.js"],"names":["define","obj1","path","obj2","split","length","ns","i","name","_attach","skylark","attach","obj","main","textmask","defaultArray","emptyString","adjustCaretPosition","previousConformedValue","previousPlaceholder","currentCaretPosition","conformedValue","rawValue","placeholderChar","placeholder","indexesOfPipedChars","caretTrapIndexes","rawValueLength","previousConformedValueLength","placeholderLength","conformedValueLength","editLength","isAddition","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","normalizedRawValue","leftHalfChars","substr","intersection","filter","char","indexOf","previousLeftMaskChars","leftMaskChars","masklengthChanged","targetIsMaskMovingLeft","undefined","pipedChars","map","index","countTargetCharInPipedChars","countTargetCharInIntersection","countTargetCharInPlaceholder","requiredNumberOfMatches","numberOfEncounteredMatches","conformedValueChar","lastPlaceholderChar","strFunction","constants","emptyArray","isArray","value","Array","strCaretTrap","convertMaskToPlaceholder","mask","Error","JSON","stringify","RegExp","join","isString","String","isNumber","isNaN","isNil","processCaretTraps","indexes","indexOfCaretTrap","push","splice","maskWithoutCaretTraps","utilities","conformToMask","config","guide","keepCharPositions","suppressGuide","maskLength","editDistance","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","slice","rawValueArr","isNew","shouldOffset","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","shift","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","indexOfLastFilledPlaceholderChar","meta","a","strNone","strObject","isAndroid","navigator","userAgent","defer","requestAnimationFrame","setTimeout","createTextMaskInputElement","state","[object Object]","inputElement","providedMask","pipe","showMask","safeRawValue","inputValue","getSafeRawValue","selectionEnd","conformToMaskConfig","piped","pipeResults","Object","assign","rejected","finalConformedValue","adjustedCaretPosition","inputValueShouldBeEmpty","emptyValue","inputElementValue","element","selectionPosition","document","activeElement","setSelectionRange","maskInput","textMaskConfig","textMaskInputElement","inputHandler","target","update","addEventListener","removeEventListener"],"mappings":"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","file":"../skylark-textmask-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        return ns[name] = obj2;\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var skylark = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(skylark,path,obj);\r\n    \t}\r\n    };\r\n    return skylark;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-langx/skylark',[\r\n    \"skylark-langx-ns\"\r\n], function(ns) {\r\n\treturn ns;\r\n});\r\n\ndefine('skylark-textmask/textmask',[\r\n\t\"skylark-langx/skylark\"\r\n],function (skylark) {\r\n    'use strict';\r\n\r\n\treturn skylark.attach(\"intg.textmask\",{\r\n\t});\t\t\r\n\r\n}); \ndefine('skylark-textmask/adjustCaretPosition',[\n    \"./textmask\"\n],function (textmask) {\n    'use strict';\n    const defaultArray = [];\n    const emptyString = '';\n\n    function adjustCaretPosition({previousConformedValue = emptyString, previousPlaceholder = emptyString, currentCaretPosition = 0, conformedValue, rawValue, placeholderChar, placeholder, indexesOfPipedChars = defaultArray, caretTrapIndexes = defaultArray}) {\n        if (currentCaretPosition === 0 || !rawValue.length) {\n            return 0;\n        }\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const conformedValueLength = conformedValue.length;\n        const editLength = rawValueLength - previousConformedValueLength;\n        const isAddition = editLength > 0;\n        const isFirstRawValue = previousConformedValueLength === 0;\n        const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n        if (isPartialMultiCharEdit) {\n            return currentCaretPosition;\n        }\n        const possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n        let startingSearchIndex = 0;\n        let trackRightCharacter;\n        let targetChar;\n        if (possiblyHasRejectedChar) {\n            startingSearchIndex = currentCaretPosition - editLength;\n        } else {\n            const normalizedConformedValue = conformedValue.toLowerCase();\n            const normalizedRawValue = rawValue.toLowerCase();\n            const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString);\n            const intersection = leftHalfChars.filter(char => normalizedConformedValue.indexOf(char) !== -1);\n            targetChar = intersection[intersection.length - 1];\n            const previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(char => char !== placeholderChar).length;\n            const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n            const targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n            if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n                trackRightCharacter = true;\n                targetChar = rawValue[currentCaretPosition];\n            }\n            const pipedChars = indexesOfPipedChars.map(index => normalizedConformedValue[index]);\n            const countTargetCharInPipedChars = pipedChars.filter(char => char === targetChar).length;\n            const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n            const countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter((char, index) => char === targetChar && rawValue[index] !== char).length;\n            const requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (trackRightCharacter ? 1 : 0);\n            let numberOfEncounteredMatches = 0;\n            for (let i = 0; i < conformedValueLength; i++) {\n                const conformedValueChar = normalizedConformedValue[i];\n                startingSearchIndex = i + 1;\n                if (conformedValueChar === targetChar) {\n                    numberOfEncounteredMatches++;\n                }\n                if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n                    break;\n                }\n            }\n        }\n        if (isAddition) {\n            let lastPlaceholderChar = startingSearchIndex;\n            for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    lastPlaceholderChar = i;\n                }\n                if (placeholder[i] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === placeholderLength) {\n                    return lastPlaceholderChar;\n                }\n            }\n        } else {\n            if (trackRightCharacter) {\n                for (let i = startingSearchIndex - 1; i >= 0; i--) {\n                    if (conformedValue[i] === targetChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            } else {\n                for (let i = startingSearchIndex; i >= 0; i--) {\n                    if (placeholder[i - 1] === placeholderChar || caretTrapIndexes.indexOf(i) !== -1 || i === 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n\n    return textmask.adjustCaretPosition = adjustCaretPosition;\n});\ndefine('skylark-textmask/constants',[],function () {\n    'use strict';\n    const placeholderChar = '_';\n    const strFunction = 'function';\n    return {\n        placeholderChar: placeholderChar,\n        strFunction: strFunction\n    };\n});\ndefine('skylark-textmask/utilities',['./constants'], function (constants) {\n    'use strict';\n    const emptyArray = [];\n    function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = constants.placeholderChar) {\n        if (!isArray(mask)) {\n            throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\n        }\n        if (mask.indexOf(placeholderChar) !== -1) {\n            throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + `The placeholder character that was received is: ${ JSON.stringify(placeholderChar) }\\n\\n` + `The mask that was received is: ${ JSON.stringify(mask) }`);\n        }\n        return mask.map(char => {\n            return char instanceof RegExp ? placeholderChar : char;\n        }).join('');\n    }\n    function isArray(value) {\n        return Array.isArray && Array.isArray(value) || value instanceof Array;\n    }\n    function isString(value) {\n        return typeof value === 'string' || value instanceof String;\n    }\n    function isNumber(value) {\n        return typeof value === 'number' && value.length === undefined && !isNaN(value);\n    }\n    function isNil(value) {\n        return typeof value === 'undefined' || value === null;\n    }\n    const strCaretTrap = '[]';\n    function processCaretTraps(mask) {\n        const indexes = [];\n        let indexOfCaretTrap;\n        while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\n            indexes.push(indexOfCaretTrap);\n            mask.splice(indexOfCaretTrap, 1);\n        }\n        return {\n            maskWithoutCaretTraps: mask,\n            indexes\n        };\n    }\n    return {\n        convertMaskToPlaceholder: convertMaskToPlaceholder,\n        isArray: isArray,\n        isString: isString,\n        isNumber: isNumber,\n        isNil: isNil,\n        processCaretTraps: processCaretTraps\n    };\n});\ndefine('skylark-textmask/conformToMask',[\n    \"./textmask\",\n    './utilities',\n    './constants'\n], function (textmask,utilities,constants) {\n\n    const emptyArray = [];\n    const emptyString = '';\n\n    function conformToMask(rawValue = emptyString, mask = emptyArray, config = {}) {\n        if (!utilities.isArray(mask)) {\n            if (typeof mask === constants.strFunction) {\n                mask = mask(rawValue, config);\n                mask = utilities.processCaretTraps(mask).maskWithoutCaretTraps;\n            } else {\n                throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n            }\n        }\n        const {guide = true, previousConformedValue = emptyString, placeholderChar = constants.placeholderChar, placeholder = utilities.convertMaskToPlaceholder(mask, placeholderChar), currentCaretPosition, keepCharPositions} = config;\n        const suppressGuide = guide === false && previousConformedValue !== undefined;\n        const rawValueLength = rawValue.length;\n        const previousConformedValueLength = previousConformedValue.length;\n        const placeholderLength = placeholder.length;\n        const maskLength = mask.length;\n        const editDistance = rawValueLength - previousConformedValueLength;\n        const isAddition = editDistance > 0;\n        const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0);\n        const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n        if (keepCharPositions === true && !isAddition) {\n            let compensatingPlaceholderChars = emptyString;\n            for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    compensatingPlaceholderChars += placeholderChar;\n                }\n            }\n            rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n        }\n        const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n            char,\n            isNew: i >= indexOfFirstChange && i < indexOfLastChange\n        }));\n        for (let i = rawValueLength - 1; i >= 0; i--) {\n            const {char} = rawValueArr[i];\n            if (char !== placeholderChar) {\n                const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n                if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n                    rawValueArr.splice(i, 1);\n                }\n            }\n        }\n        let conformedValue = emptyString;\n        let someCharsRejected = false;\n        placeholderLoop:\n            for (let i = 0; i < placeholderLength; i++) {\n                const charInPlaceholder = placeholder[i];\n                if (charInPlaceholder === placeholderChar) {\n                    if (rawValueArr.length > 0) {\n                        while (rawValueArr.length > 0) {\n                            const {\n                                char: rawValueChar,\n                                isNew\n                            } = rawValueArr.shift();\n                            if (rawValueChar === placeholderChar && suppressGuide !== true) {\n                                conformedValue += placeholderChar;\n                                continue placeholderLoop;\n                            } else if (mask[i].test(rawValueChar)) {\n                                if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString || guide === false || !isAddition) {\n                                    conformedValue += rawValueChar;\n                                } else {\n                                    const rawValueArrLength = rawValueArr.length;\n                                    let indexOfNextAvailablePlaceholderChar = null;\n                                    for (let i = 0; i < rawValueArrLength; i++) {\n                                        const charData = rawValueArr[i];\n                                        if (charData.char !== placeholderChar && charData.isNew === false) {\n                                            break;\n                                        }\n                                        if (charData.char === placeholderChar) {\n                                            indexOfNextAvailablePlaceholderChar = i;\n                                            break;\n                                        }\n                                    }\n                                    if (indexOfNextAvailablePlaceholderChar !== null) {\n                                        conformedValue += rawValueChar;\n                                        rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n                                    } else {\n                                        i--;\n                                    }\n                                }\n                                continue placeholderLoop;\n                            } else {\n                                someCharsRejected = true;\n                            }\n                        }\n                    }\n                    if (suppressGuide === false) {\n                        conformedValue += placeholder.substr(i, placeholderLength);\n                    }\n                    break;\n                } else {\n                    conformedValue += charInPlaceholder;\n                }\n            }\n        if (suppressGuide && isAddition === false) {\n            let indexOfLastFilledPlaceholderChar = null;\n            for (let i = 0; i < conformedValue.length; i++) {\n                if (placeholder[i] === placeholderChar) {\n                    indexOfLastFilledPlaceholderChar = i;\n                }\n            }\n            if (indexOfLastFilledPlaceholderChar !== null) {\n                conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n            } else {\n                conformedValue = emptyString;\n            }\n        }\n        return {\n            conformedValue,\n            meta: { someCharsRejected }\n        };\n    }\n\n\n    return textmask.conformToMask = conformToMask;\n    \n});\ndefine('skylark-textmask/createTextMaskInputElement',[\n    \"./textmask\",\n    './adjustCaretPosition',\n    './conformToMask',\n    './utilities',\n    './constants'\n], function (textmask,adjustCaretPosition, conformToMask, a,constants) {\n    'use strict';\n\n    const emptyString = '';\n    const strNone = 'none';\n    const strObject = 'object';\n    const isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n    const defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\n\n    function createTextMaskInputElement(config) {\n        const state = {\n            previousConformedValue: undefined,\n            previousPlaceholder: undefined\n        };\n        return {\n            state,\n            update(rawValue, {\n                inputElement,\n                mask: providedMask,\n                guide,\n                pipe,\n                placeholderChar = constants.placeholderChar,\n                keepCharPositions = false,\n                showMask = false\n            } = config) {\n                if (typeof rawValue === 'undefined') {\n                    rawValue = inputElement.value;\n                }\n                if (rawValue === state.previousConformedValue) {\n                    return;\n                }\n                if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n                    pipe = providedMask.pipe;\n                    providedMask = providedMask.mask;\n                }\n                let placeholder;\n                let mask;\n                if (providedMask instanceof Array) {\n                    placeholder = a.convertMaskToPlaceholder(providedMask, placeholderChar);\n                }\n                if (providedMask === false) {\n                    return;\n                }\n                const safeRawValue = getSafeRawValue(rawValue);\n                const {selectionEnd: currentCaretPosition} = inputElement;\n                const {previousConformedValue, previousPlaceholder} = state;\n                let caretTrapIndexes;\n                if (typeof providedMask === constants.strFunction) {\n                    mask = providedMask(safeRawValue, {\n                        currentCaretPosition,\n                        previousConformedValue,\n                        placeholderChar\n                    });\n                    if (mask === false) {\n                        return;\n                    }\n                    const {maskWithoutCaretTraps, indexes} = a.processCaretTraps(mask);\n                    mask = maskWithoutCaretTraps;\n                    caretTrapIndexes = indexes;\n                    placeholder = a.convertMaskToPlaceholder(mask, placeholderChar);\n                } else {\n                    mask = providedMask;\n                }\n                const conformToMaskConfig = {\n                    previousConformedValue,\n                    guide,\n                    placeholderChar,\n                    pipe,\n                    placeholder,\n                    currentCaretPosition,\n                    keepCharPositions\n                };\n                const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n                const piped = typeof pipe === constants.strFunction;\n                let pipeResults = {};\n                if (piped) {\n                    pipeResults = pipe(conformedValue, Object.assign({\n                        rawValue: safeRawValue\n                    },conformToMaskConfig));\n                    if (pipeResults === false) {\n                        pipeResults = {\n                            value: previousConformedValue,\n                            rejected: true\n                        };\n                    } else if (a.isString(pipeResults)) {\n                        pipeResults = { value: pipeResults };\n                    }\n                }\n                const finalConformedValue = piped ? pipeResults.value : conformedValue;\n                const adjustedCaretPosition = adjustCaretPosition({\n                    previousConformedValue,\n                    previousPlaceholder,\n                    conformedValue: finalConformedValue,\n                    placeholder,\n                    rawValue: safeRawValue,\n                    currentCaretPosition,\n                    placeholderChar,\n                    indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n                    caretTrapIndexes\n                });\n                const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n                const emptyValue = showMask ? placeholder : emptyString;\n                const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n                state.previousConformedValue = inputElementValue;\n                state.previousPlaceholder = placeholder;\n                if (inputElement.value === inputElementValue) {\n                    return;\n                }\n                inputElement.value = inputElementValue;\n                safeSetSelection(inputElement, adjustedCaretPosition);\n            }\n        };\n    };\n    function safeSetSelection(element, selectionPosition) {\n        if (document.activeElement === element) {\n            if (isAndroid) {\n                defer(() => element.setSelectionRange(selectionPosition, selectionPosition, strNone), 0);\n            } else {\n                element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n            }\n        }\n    }\n    function getSafeRawValue(inputValue) {\n        if (a.isString(inputValue)) {\n            return inputValue;\n        } else if (a.isNumber(inputValue)) {\n            return String(inputValue);\n        } else if (inputValue === undefined || inputValue === null) {\n            return emptyString;\n        } else {\n            throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value \" + `received was:\\n\\n ${ JSON.stringify(inputValue) }`);\n        }\n    }\n\n\n    return textmask.createTextMaskInputElement = createTextMaskInputElement;\n});\ndefine('skylark-textmask/maskInput',[\r\n    \"./textmask\",\r\n\t'./createTextMaskInputElement'\r\n],function (textmask,createTextMaskInputElement) {\r\n    'use strict';\r\n\r\n\r\n\tfunction maskInput(textMaskConfig) {\r\n\t  const {inputElement} = textMaskConfig\r\n\t  const textMaskInputElement = createTextMaskInputElement(textMaskConfig)\r\n\t  const inputHandler = ({target: {value}}) => textMaskInputElement.update(value)\r\n\r\n\t  inputElement.addEventListener('input', inputHandler)\r\n\r\n\t  textMaskInputElement.update(inputElement.value)\r\n\r\n\t  return {\r\n\t    textMaskInputElement,\r\n\r\n\t    destroy() {\r\n\t      inputElement.removeEventListener('input', inputHandler)\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\treturn textmask.maskInput = maskInput;\r\n\r\n}); \ndefine('skylark-textmask/main',[\n\t\"./textmask\",\n\t\"./maskInput\"\n],function (textmask) {\n    'use strict';\n\n\treturn textmask;\n\n}); \ndefine('skylark-textmask', ['skylark-textmask/main'], function (main) { return main; });\n\n"]}